// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: contract.sql

package db

import (
	"context"
	"time"
)

const createContract = `-- name: CreateContract :one
WITH contracts AS (
  INSERT INTO contracts
    ("owner", template)
  VALUES
    ($1, $2)
  RETURNING id, owner, template, created_at),
parties AS (
  INSERT INTO parties
    (username, contract_id, role)
  SELECT $1, id, 'owner' FROM contracts
  RETURNING username, role, contract_id, created_at
)
SELECT id, owner, template, created_at
FROM contracts
LIMIT 1
`

type CreateContractParams struct {
	Owner    string `json:"owner"`
	Template string `json:"template"`
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, createContract, arg.Owner, arg.Template)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Template,
		&i.CreatedAt,
	)
	return i, err
}

const getContract = `-- name: GetContract :one
SELECT id, owner, template, created_at FROM contracts
WHERE owner=$1 AND template=$2 AND created_at=$3
LIMIT 1
`

type GetContractParams struct {
	Owner     string    `json:"owner"`
	Template  string    `json:"template"`
	CreatedAt time.Time `json:"createdAt"`
}

func (q *Queries) GetContract(ctx context.Context, arg GetContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, getContract, arg.Owner, arg.Template, arg.CreatedAt)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Template,
		&i.CreatedAt,
	)
	return i, err
}

const listContracts = `-- name: ListContracts :many
SELECT contracts.id, contracts.owner, contracts.template, contracts.created_at 
  FROM parties JOIN contracts ON parties.contract_id = contracts.id
  WHERE parties.username = $1
  ORDER BY contracts.created_at
  LIMIT $2
  OFFSET $3
`

type ListContractsParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListContracts(ctx context.Context, arg ListContractsParams) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, listContracts, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contract{}
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Template,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContract = `-- name: UpdateContract :one
UPDATE contracts SET template = $2
WHERE id = $1
RETURNING id, owner, template, created_at
`

type UpdateContractParams struct {
	ID       int64  `json:"id"`
	Template string `json:"template"`
}

func (q *Queries) UpdateContract(ctx context.Context, arg UpdateContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, updateContract, arg.ID, arg.Template)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Template,
		&i.CreatedAt,
	)
	return i, err
}
